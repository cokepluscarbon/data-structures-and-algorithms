#11.散列

##11.1 基本数据类型散列
对于**byte**,**short**,**int**和**char**这些基本类型数据，统一转为int类型，并把这个数值当做**散列值**。而对于**float**类型，则采用`Float.floatToIntBits(key)`的返回值作为散列值（该函数返回的int类型的二进制表示跟该float类型的二进制表示是一样的）。

对于**long**类型数据，最简单的做法是采用低4字节作为散列值，但long类型占有8字节数据，此种做法很容易引起**散列碰撞**，最好的做法是：
```Java
int hashCode = (int)(key^(key>>32));
```
将原来的key右移32位并与原来的key做**按位异或**操作，取低4字节作为散列值，这样long类型的高4字节和低4字节都参与了散列值的计算，大大降低了碰撞的概率。

而对应**double**类型数据，首先将key转为double表示（Double.doubleToLongBits(key)）,剩下的跟long的散列值一致：

```Java
long longkey = Double.doubleToLongBits(key);
int hashCode = (int)(longkey^(longkey>>32));
```

###11.1.3 String类型散列
由于String经常被作为key，所以设计一个好的String散列函数是非常重要的。最直接的做法就是获取字符串的每个字符的Unicode编码，并将这些数值相加：
```Java
int hashCode = 0;
for(int i=0; str.length; i++) {
    hashCode += str.charAt(i);
}
```
这种做法计算散列值十分快，每个字符也参与了计算，但是碰撞的概率也非常大，例如bat和atb的散列值是一样的。为了减少碰撞，我们可以让每个字符的位置参与计算：
```
s[0]*b^(n-1) + s[1]*b^(n-2) + ... + s[n-1]
```
为了方便计算，这个多项式可以简化为：
```
(...(s[0] + s[1])b + ... + s[n-2])b + s[n-1]
```


Search keys are often strings, so it is important to design a good hash function for strings. An
intuitive approach is to sum the Unicode of all characters as the hash code for the string. This
approach may work if two search keys in an application don’t contain the same letters, but it

will produce a lot of collisions if the search keys contain the same letters, such as todand
dot.
A better approach is to generate a hash code that takes the position of characters into consideration. Specifically, let the hash code be
wheres
i
iss.charAt(i). This expression is a polynomial for some positive b, so this is called
apolynomial hash code. Using Horner’s rule for polynomial evaluation (see Section 9.4), the
hash code can be calculated efficiently as follows:
This computation can cause an overflow for long strings, but arithmetic overflow is ignored in
Java. You should choose an appropriate value bto minimize collisions. Experiments show
that good choices for bare 31, 33, 37, 39, and 41. In the Stringclass, the hashCodeis overridden using the polynomial hash code with bbeing31.

###11.1.3 其他

##11.2 压缩散列码

##11.3 处理散列碰撞

##11.4 HashMap实现


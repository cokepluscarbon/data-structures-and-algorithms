#11.散列

##11.1 基本数据类型散列
对于**byte**,**short**,**int**和**char**这些基本类型数据，统一转为int类型，并把这个数值当做**散列值**。而对于**float**类型，则采用`Float.floatToIntBits(key)`的返回值作为散列值（该函数返回的int类型的二进制表示跟该float类型的二进制表示是一样的）。

对于**long**类型数据，最简单的做法是采用低4字节作为散列值，但long类型占有8字节数据，此种做法很容易引起**散列碰撞**，最好的做法是：
```Java
int hashCode = (int)(key^(key>>32));
```
将原来的key右移32位并与原来的key做**按位异或**操作，取低4字节作为散列值，这样long类型的高4字节和低4字节都参与了散列值的计算，大大降低了碰撞的概率。

而对应**double**类型数据，首先将key转为double表示（Double.doubleToLongBits(key)）,剩下的跟long的散列值一致：

```Java
long longkey = Double.doubleToLongBits(key);
int hashCode = (int)(longkey^(longkey>>32));
```

###11.1.3 String类型散列
由于String经常被作为key，所以设计一个好的String散列函数是非常重要的。最直接的做法就是获取字符串的每个字符的Unicode编码，并将这些数值相加：
```Java
int hashCode = 0;
for(int i=0; str.length; i++) {
    hashCode += str.charAt(i);
}
```
这种做法计算散列值十分快，每个字符也参与了计算，但是碰撞的概率也非常大，例如bat和atb的散列值是一样的。为了减少碰撞，我们可以让每个字符的位置参与计算：
```
s[0]*b^(n-1) + s[1]*b^(n-2) + ... + s[n-1]
```
为了方便计算，这个多项式可以简化为：
```
(...((s[0]*b + s[1])b + ... + s[n-2])b + s[n-1]
```
在计算过程中，多项式难免越界，我们可以将其忽略，只取低32位的二级制位作为散列值，而同时为了减少碰撞，**b**最好为质数，且为了减少越界和计算量，这个质数通常不能取的太大（但不能过小），实验证明**31**, **33**, **37**, **39**, and **41**都是不错的选择。

以下是JDK的`String.hashCode`方式实现：
```Java
public int hashCode() {
    int h = hash;
    if (h == 0 && value.length > 0) {
        char val[] = value;

        for (int i = 0; i < value.length; i++) {
            h = 31 * h + val[i];
        }
        hash = h;
    }
    return h;
}
```

##11.2 压缩散列码
散列值通常都会比存储数据的数组要大的多，所以，我们需要将散列值压缩至数组的下标范围内。假设数组的大小为N，下标范围为0至N-1，最常用的压缩方法就是使用**求余法**：
```
h(hashCode) = hashCode % N;
```
为了散列均匀分布，在理想情况下，**N**最好是一个质数。然而寻找质数本身就是一个非常消耗性能的操作。在Java API中的HashMap里，N的取值为**2的指数（the power of 2）**。这样的好处在于：当N为2的指数时，以下两个操作是等价的：
```
h(hashCode) = hashCode % N;   等价于  h(hashCode) = hashCode & (N – 1);
```
而第二个的性能明显要远由于第一个。

The hash code for a key can be a large integer that is out of the range for the hash-table index,
so you need to scale it down to fit in the index’s range. Assume the index for a hash table is
between0andN-1. The most common way to scale an integer to between 0andN-1is to use
h(hashCode) = hashCode % N
To ensure that the indices are spread evenly, choose Nto be a prime number greater than 2.
Ideally, you should choose a prime number for N. However, it is time consuming to find a
large prime number. In the Java API implementation for java.util.HashMap, Nis set to a
value of the power of 2. There is a good reason for this choice. When Nis a value of the power
of2,
h(hashCode) = hashCode % N
is the same as
h(hashCode) = hashCode & (N – 1)
The ampersand, &, is a bitwise AND operator (see Appendix G, Bitwise Operations). The
AND of two corresponding bits yields a 1if both bits are 1. For example, assume N = 4and
hashCode = 11,11 % 4 = 3, which is the same as 01011 & 00011 = 11. The &operator can be performed much faster than the %operator.
To ensure that the hashing is evenly distributed, a supplemental hash function is also used
along with the primary hash function in the implementation of java.util.HashMap. The
supplemental function is defined as: 
private static intsupplementalHash(inth) {
h ^= (h >>> 20) ^ (h >>> 12);
returnh ^ (h >>> 7) ^ (h >>> 4);
}
^and>>>are bitwise exclusive-or and unsigned right-shift operations (also introduced in
Appendix G). The bitwise operations are much faster than the multiplication, division, and
remainder operations. You should replace these operations with the bitwise operations whenever possible.
The complete hash function is defined as:
h(hashCode) = supplementalHash(hashCode) % N

polynomial hash code
28.4 Handling Collisions Using Open Addressing 1001

This is the same as
h(hashCode) = supplementalHash(hashCode) & (N – 1)
sinceNis a value of the power of 2.


##11.3 处理散列碰撞

##11.4 HashMap实现


#11.散列

##11.1 基本数据类型散列
对于**byte**,**short**,**int**和**char**这些基本类型数据，统一转为int类型，并把这个数值当做**散列值**。而对于**float**类型，则采用`Float.floatToIntBits(key)`的返回值作为散列值（该函数返回的int类型的二进制表示跟该float类型的二进制表示是一样的）。

对于**long**类型数据，最简单的做法是采用低4字节作为散列值，但long类型占有8字节数据，此种做法很容易引起**散列碰撞**，最好的做法是：
```Java
int hashCode = (int)(key^(key>>32));
```
将原来的key右移32位并与原来的key做**按位异或**操作，取低4字节作为散列值，这样long类型的高4字节和低4字节都参与了散列值的计算，大大降低了碰撞的概率。

而对应**double**类型数据，首先将key转为double表示（Double.doubleToLongBits(key)）,剩下的跟long的散列值一致：

```Java
long longkey = Double.doubleToLongBits(key);
int hashCode = (int)(longkey^(longkey>>32));
```

###11.1.3 String类型散列
由于String经常被作为key，所以设计一个好的String散列函数是非常重要的。最直接的做法就是获取字符串的每个字符的Unicode编码，并将这些数值相加：
```Java
int hashCode = 0;
for(int i=0; str.length; i++) {
    hashCode += str.charAt(i);
}
```
这种做法计算散列值十分快，每个字符也参与了计算，但是碰撞的概率也非常大，例如bat和atb的散列值是一样的。为了减少碰撞，我们可以让每个字符的位置参与计算：
```
s[0]*b^(n-1) + s[1]*b^(n-2) + ... + s[n-1]
```
为了方便计算，这个多项式可以简化为：
```
(...((s[0]*b + s[1])b + ... + s[n-2])b + s[n-1]
```
在计算过程中，多项式难免越界，我们可以将其忽略，只取低32位的二级制位作为散列值，而同时为了减少碰撞，**b**最好为质数，且为了减少越界和计算量，这个质数通常不能取的太大（但不能过小），实验证明**31**, **33**, **37**, **39**, and**41**都是不错的选择。

以下是JDK的`String.hashCode`方式实现：
```Java
public int hashCode() {
    int h = hash;
    if (h == 0 && value.length > 0) {
        char val[] = value;

        for (int i = 0; i < value.length; i++) {
            h = 31 * h + val[i];
        }
        hash = h;
    }
    return h;
}
```

###11.1.3 其他

##11.2 压缩散列码

##11.3 处理散列碰撞

##11.4 HashMap实现


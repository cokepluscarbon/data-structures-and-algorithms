#01.最大子序列和

 **问题：** 给定（可能有负数的）正数A1，A2，A3，...，An，求它的连续子序列的最大和。
 
 这个问题在学习算法的时候经常会被引用到，因为解决它的算法有很多种，并而这些算法的性能差异又很大。
 最坏时间复杂度分别有 **O(N^3)** , **O(N^2)** , **O(NlogN)** , **O(Nlog)** 。它们的性能对比如下：
 
 <img src="images/01-01.gif"/>
 
##1.O(N^3)解法：穷举法
 
 穷举法也就是最笨的方法，将所有的子序列的和全部算出来，然后比较得出最大的子序列和，由于嵌套了三层循环，最坏时间复杂度为O(N^3)。
 
	@Test
	public void t_001_n3() {
		int maxSum = 0;
		for (int i = 0; i < data.length; i++) { // 从第i个数开始取
			for (int j = i; j < data.length; j++) { // 取到第j个数停止
				int tmpSum = 0;

				for (int k = i; k <= j; k++) { // 从i到j计算子序列大小
					tmpSum += data[k];
				}
				maxSum = tmpSum > maxSum ? tmpSum : maxSum;
			}
		}

		System.out.println("The maxSum is : " + maxSum);
	}
	
##2.O(N^2)解法：方法一的改进

 方法一中嵌套了三层循环，其中有一层循环是不必要的。例如当i=0，j=3时sum3=A0+A1+A2，而当i=0，j=4时sum4=A0+A1+A2+A3，这里进行了不必要的重复计算。
 sum4完全可以由sum3+A3得到：所以O(N^2)的解法为，由O(N^3)的三层循环改进为两层循环：
	
	
	
 
 
